{"version":3,"file":"68b7ae40d2f661cf058864245f3dd9acaa661d89-b05cfba6b89122d1eb31.js","mappings":"kJAKO,IAAMA,GAAgB,8CAChBC,EAAAA,EAAAA,IAAa,QAAS,OAAQ,EAAG,GADjB,YAIvBC,GAAWC,EAAAA,EAAAA,KAAH,YACDF,EAAAA,EAAAA,IAAa,QAAS,OAAQ,IAAK,GADlC,eAIRG,GAAI,6JAmBV,KAJ8C,SAAC,GAA4C,IAAD,IAAzCC,YAAAA,OAAyC,aAApBC,MAAAA,OAAoB,SACxF,OAAO,SAACN,EAAD,CAAkBG,IAAKG,GAASJ,IAAYG,IAAe,SAACD,EAAD,S,0ECvBpE,IAAMG,GAAO,gKAAb,qDAyDA,IA1C0C,SAAC,GAAuD,IAArDC,EAAoD,EAApDA,MAAOC,EAA6C,EAA7CA,MAAOC,EAAsC,EAAtCA,OAAsC,IAA9BC,mBAAAA,OAA8B,MAAT,GAAS,EACzFC,GAAaC,EAAAA,EAAAA,QAAuB,MACpCC,GAAWD,EAAAA,EAAAA,QAAyB,MAW1C,OAPAE,EAAAA,EAAAA,IAAoBH,GAAY,SAACI,GAC/B,GAAKF,EAASG,QAAd,CAEA,IAAMC,EAAQ,EAAMF,GALL,IAK4B,GAC3CF,EAASG,QAAQE,MAAMC,UAAvB,SAA4CF,EAA5C,SAIA,SAACX,EAAD,CACEc,IAAKT,EACLT,KAAKA,EAAAA,EAAAA,KAAF,UACSQ,EADT,aAIH,gBACEU,IAAKP,EACLX,KAAKA,EAAAA,EAAAA,KAAF,gDAEoBM,EAAQ,IAF5B,0CAOH,SAAC,IAAD,CACEN,IAAG,EAGHM,MAAOA,EACPC,OAAQA,EACRY,IAAKd,Q,oHClDFe,EAAU,SAACC,GAAD,OAA4B,EAAIC,KAAKC,IAAIF,EAAQC,KAAKE,KAAO,GAOvEC,EAAsB,SAACC,GAClC,IAAMC,EAAaD,EAAQE,wBACrBC,EAAaF,EAAWG,IACxBC,EAAQC,OAAOC,YACfC,GAAOP,EAAWpB,OACxB,OAAOe,KAAKa,IAAI,EAAKb,KAAKc,IAAI,GAAMP,EAAaE,IAAUG,EAAMH,MAatDnB,EAAsB,SACjCM,EACAmB,EACAC,QAMS,IANTA,IAAAA,EAKI,IAEJ,MAA2BA,EAAnBC,QAAAA,OAAR,MAAkB,IAAlB,GAEAC,EAAAA,EAAAA,YAAU,WACR,GAAKtB,EAAIJ,QAAT,CACA,IAAMY,EAAUR,EAAIJ,QAEhB2B,GAAc,EAQZC,EAAgB,WACpBD,GAAc,GAGZE,EAAe,EAIbC,EAAY,SAAZA,IACJ,IAAMd,EAAMR,KAAKa,IAAI,EAAKT,EAAQE,wBAAwBE,IAAME,OAAOa,QAAUb,OAAOC,aAClFa,EAASpB,EAAQE,wBAAwBkB,OAASd,OAAOa,QAE3DhC,GAAYmB,OAAOa,QAAUf,IAAQgB,EAAShB,GAG9CR,KAAKyB,IAAIlC,EAAW8B,GAAgBJ,IAEpC1B,EADEA,EAAW8B,EACFA,EAAeJ,EAEfI,EAAeJ,GAI9BI,EAAe9B,EACfwB,EAASxB,GAEL4B,GACFT,OAAOgB,sBAAsBJ,IAI3BK,EAAW,IAAIC,sBACnB,SAACC,GACKA,EAAQ,GAAGC,eAtCZX,IACHA,GAAc,EACdG,KAuCEF,MAGJ,CACEW,WAAY,MACZC,UAAW,IAKf,OAFAL,EAASM,QAAQ7B,GAEV,WACLuB,EAASO,aACTd,QAED,CAACxB,EAAIJ","sources":["webpack://toit.io/./src/components/ContentSpacer.tsx","webpack://toit.io/./src/components/HeroImage.tsx","webpack://toit.io/./src/helper.ts"],"sourcesContent":["import { css } from \"@emotion/react\";\nimport styled from \"@emotion/styled\";\nimport * as React from \"react\";\nimport { clampBuilder } from \"./global-css\";\n\nexport const ContentSpacerDiv = styled.div`\n  padding: ${clampBuilder(\"small\", \"huge\", 3, 6)} 1.5rem;\n`;\n\nconst largeCss = css`\n  padding: ${clampBuilder(\"small\", \"huge\", 4.5, 9)} 1.5rem;\n`;\n\nconst Line = styled.hr`\n  height: 1px;\n  background: currentColor;\n  border: none;\n  margin: 0;\n  @media (min-width: 450px) {\n    display: none;\n  }\n`;\n\ntype Props = {\n  large?: boolean;\n  preventLine?: boolean;\n};\n\nexport const ContentSpacer: React.FC<Props> = ({ preventLine = false, large = false }) => {\n  return <ContentSpacerDiv css={large && largeCss}>{!preventLine && <Line />}</ContentSpacerDiv>;\n};\n\nexport default ContentSpacer;\n","import { css } from \"@emotion/react\";\nimport styled from \"@emotion/styled\";\nimport React, { useRef } from \"react\";\nimport { useViewportPosition } from \"../helper\";\nimport LazyImage from \"./LazyImage\";\n\nconst Wrapper = styled.div`\n  display: block;\n  position: relative;\n  overflow: hidden;\n  text-align: center;\n  padding: 0 var(--contentPadding);\n`;\n\nexport type Props = {\n  image: string;\n  width: number;\n  height: number;\n  containerHeightRem?: number;\n};\n\nexport const HeroImage: React.FC<Props> = ({ image, width, height, containerHeightRem = 20 }) => {\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const imageRef = useRef<HTMLImageElement>(null);\n\n  const maxScale = 1.2;\n\n  useViewportPosition(wrapperRef, (position) => {\n    if (!imageRef.current) return;\n\n    const scale = 1.0 + position * (maxScale - 1);\n    imageRef.current.style.transform = `scale(${scale})`;\n  });\n\n  return (\n    <Wrapper\n      ref={wrapperRef}\n      css={css`\n        height: ${containerHeightRem}rem;\n      `}\n    >\n      <div\n        ref={imageRef}\n        css={css`\n          transform-origin: left top;\n          @media (min-width: ${width + 120}px) {\n            transform-origin: center top;\n          }\n        `}\n      >\n        <LazyImage\n          css={css`\n            max-width: none !important;\n          `}\n          width={width}\n          height={height}\n          src={image}\n        />\n      </div>\n    </Wrapper>\n  );\n};\n\nexport default HeroImage;\n","import { RefObject, useEffect } from \"react\";\n\n/**\n * Converts a linear value interpolation (from 0.0 to 1.0) to an ease-out\n * interpolation (also from 0.0 to 1.0).\n */\nexport const easeOut = (value: number): number => (1 - Math.cos(value * Math.PI)) / 2;\n\n/**\n * Returns a number from 0.0 to 1.0 corresponding to the visibility in the\n * viewport. When it just starts appearing at the top it bottom at 0.0,\n * and when it's scrolls out of view at the top, it's a 1.0.\n */\nexport const getViewportPosition = (element: HTMLElement): number => {\n  const clientRect = element.getBoundingClientRect();\n  const elementTop = clientRect.top;\n  const start = window.innerHeight;\n  const end = -clientRect.height;\n  return Math.max(0.0, Math.min(1.0, (elementTop - start) / (end - start)));\n};\n\n/**\n * Invokes the callback every time given element is in the viewport.\n *\n * The position passed to the callback is the value determined by\n * `getViewportPosition`.\n *\n * This function however takes care of a few other things like interpolation\n * steps (to avoid jagged animation on stepped mouse scrolling) and\n * adding/removing the observers when needed.\n */\nexport const useViewportPosition = (\n  ref: RefObject<HTMLElement>,\n  callback: (position: number) => void,\n  options: {\n    // The maximumg amount of steps that should be jumped from one position to\n    // the next. This allows for a smooth animation even when scrolling with\n    // the mouse.\n    maxStep?: number;\n  } = {}\n): void => {\n  const { maxStep = 0.03 } = options;\n\n  useEffect(() => {\n    if (!ref.current) return;\n    const element = ref.current;\n\n    let isAnimating = false;\n\n    const startAnimating = () => {\n      if (!isAnimating) {\n        isAnimating = true;\n        loopCycle();\n      }\n    };\n    const stopAnimating = () => {\n      isAnimating = false;\n    };\n\n    let prevPosition = 0.0;\n\n    // Using a loop cycle with animation frame instead of a scroll listener\n    // so we can interpolate between different positions.\n    const loopCycle = () => {\n      const top = Math.max(0.0, element.getBoundingClientRect().top + window.scrollY - window.innerHeight);\n      const bottom = element.getBoundingClientRect().bottom + window.scrollY;\n\n      let position = (window.scrollY - top) / (bottom - top);\n\n      // Add some linear interpolation between the steps.\n      if (Math.abs(position - prevPosition) > maxStep) {\n        if (position > prevPosition) {\n          position = prevPosition + maxStep;\n        } else {\n          position = prevPosition - maxStep;\n        }\n      }\n\n      prevPosition = position;\n      callback(position);\n\n      if (isAnimating) {\n        window.requestAnimationFrame(loopCycle);\n      }\n    };\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting) {\n          startAnimating();\n        } else {\n          stopAnimating();\n        }\n      },\n      {\n        rootMargin: \"0px\",\n        threshold: 0,\n      }\n    );\n    observer.observe(element);\n\n    return () => {\n      observer.disconnect();\n      stopAnimating();\n    };\n  }, [ref.current]);\n};\n"],"names":["ContentSpacerDiv","clampBuilder","largeCss","css","Line","preventLine","large","Wrapper","image","width","height","containerHeightRem","wrapperRef","useRef","imageRef","useViewportPosition","position","current","scale","style","transform","ref","src","easeOut","value","Math","cos","PI","getViewportPosition","element","clientRect","getBoundingClientRect","elementTop","top","start","window","innerHeight","end","max","min","callback","options","maxStep","useEffect","isAnimating","stopAnimating","prevPosition","loopCycle","scrollY","bottom","abs","requestAnimationFrame","observer","IntersectionObserver","entries","isIntersecting","rootMargin","threshold","observe","disconnect"],"sourceRoot":""}